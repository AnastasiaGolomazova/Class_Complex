#include "Complex.h"

Complex::Complex() { // конатруктор по умолчанию, он вызывается, если пользователем не указаные значения для инициализации.
	re = 0; // по умолчанию мы все присваиваем к 0
	im = 0;
}

Complex::Complex(double iValue) { // данный конатруктор используется при условии, что введена только мнимая часть, которой присваивается значение
	re = 0;
	im = iValue;
}

Complex::Complex(double rValue, double iValue) { // данный конатруктор используется при условии, что введены все значения
	re = rValue;
	im = iValue;
}

// перегрузка операторов, так как работа с комплексными числами изначально в с++ отсутствуе, то введем основые действия с комплексными числами
Complex Complex::operator+(Complex& c) { // при вызове функции переменная "с" класса комплекс станет ссылкой на аргумент. В данном случае мы используем ссылку на переменную, для того чтобы работать непосредственно с исходным значением аргумента.
	return Complex(re + c.re, im + c.im); // в данной перегрузке, как и в друих следующих, мы работаем с объектом класса комплекс, с которым будут производится действия. А именно с отдельными его мнимой и действительной частью. После получения результата, мы его возвращем
};

Complex Complex::operator-(Complex& c) {
	return Complex(re - c.re, im - c.im);
};

Complex Complex::operator*(Complex& c) {
	return Complex(re * c.re - im * c.im, re * c.im + im * c.re);
};



Complex Complex::operator/ (Complex& c){ // в этой перегрузке мы работаем непосредственно с оператором деления и проверяем исключение (деление на 0) 
	
	if ((pow(c.re, 2) + pow(c.im, 2)) == 0 || (pow(c.re, 2) + pow(c.im, 2)) == 0) { // ставим условие, если 2 нижнии части формулы "деления комплексного числа" == 0, то мы ловим исключение
		throw 0;
	}
	else { // если мы не поймали исключения, то можем делить
		return Complex((re * c.re + im * c.im) / (pow(c.re, 2) + pow(c.im, 2)) + (im * c.re + re * c.im) / (pow(c.re, 2) + pow(c.im, 2)));
	}
};



ostream& operator<<(ostream& out, Complex& c) { // перед нами дружесвенная функция, которая изначально не имеет доступ к членам класса, чтобы ее использовать присваиваем ей ключевое слово friend, а также подключаемся к переменной, которая отвечает за вывод на клавиатуру
	bool flag = false; // вносим переменную которая будет выполнять функцию рычага
	if (c.re != 0.0) { // если имеется случай, когда действительная часть "с" не равна 0
		out << c.re << " "; // то вывести действительную часть "с" с пробелом
		flag = true; // и вернуть значение true 
	}
	if (c.im != 0.0) { // если мнимая часть также не равна 0
		if (!flag) { // и если отсутсвует действительная часть
			out << c.im; // то выводим мнимую часть
			flag = true; //  возвращаем значение true 
		}
		else { // иначе существует действительная часть
			if (c.im > 0) // если мнимая часть больше 0
				out << "+ " << c.im; // выводим +
			else
				out << "- " << (-c.im); // иначе выводим -
		}
		out << "i"; // также в конце добавляем i
	}
	if (!flag) //  если действительная и мнимая части равны 0
		out << "0"; //  выводим 0
	return out;
}

istream& operator>>(istream& in, Complex& c) { // такая же дружественная фнкция, но отвечающая за ввод с клавиатуры, где мы поочередно вводим действительную и мнимую части
	in >> c.re;
	in >> c.im;
	return in;
}

//Функции досупа, геттеры и сеттеры

void Complex::setComplex(double rValue, double iValue) { // cеттеры позволяют присваивать значения закрытым членам класса. Вданном случае переприсваиваем и мнимую и действительную части
	re = rValue;
	im = iValue;
}

void Complex::setRe(double rValue) { // отдельно сеттер для действительной части
	re = rValue;
}

void Complex::setIm(double iValue) { // отдельно сеттер для мнимой части
	im = iValue;
}

void Complex::getComplex(double& rValue, double& iValue) { // геттеры возвращают значения закрытых переменных класса. В данном случае достаем мнимую и действительную части
	rValue = re;
	iValue = im;
}

double Complex::getRe() { // отдельно геттер для действительной части
	return re;
}

double Complex::getIm() { // отдельно геттер для мнимой части
	return im;
}
